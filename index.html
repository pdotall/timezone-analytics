<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>UTC Timezones — SIM (Frontend-Only)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Interactive UTC timezones with real polygons — frontend only using Dune SIM proxy." />
    <style>
      html, body { margin: 0; height: 100%; background: #0b1020; }
      #root { min-height: 100vh; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useEffect, useRef, useState } = React;

      /* ---------- CONFIG ---------- */
      const SIM_BASE = 'https://smart-money.pdotcapital.workers.dev/v1';

      /* ---------- HELPERS ---------- */
      const getZoneName = (props = {}) =>
        props.tzid || props.TZID || props.time_zone || props.NAME || props.name || 'Timezone';

      const isEvm = (s) => /^(0x)[0-9a-fA-F]{40}$/.test(s);
      const isSol = (s) => /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(s);

      const parseAddresses = (text) => {
        const parts = String(text || '')
          .split(/[\s,;\n\r]+/)
          .map((s) => s.trim())
          .filter(Boolean);
        const seen = new Set();
        const out = [];
        for (const addr of parts) {
          let key = null;
          if (isEvm(addr)) key = addr.toLowerCase();
          else if (isSol(addr)) key = addr;
          else continue;
          if (seen.has(key)) continue;
          seen.add(key);
          out.push(addr);
        }
        return out;
      };

      const pastelFromLabel = (label) => {
        let h = 0;
        const s = String(label || '');
        for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
        const hue = h % 360;
        return `hsl(${hue} 85% 70%)`;
      };

      const isFeatureCollection = (obj) => !!obj && obj.type === 'FeatureCollection' && Array.isArray(obj.features);
      const isNumber = (x) => typeof x === 'number' && Number.isFinite(x);
      const isPosition = (p) => Array.isArray(p) && p.length >= 2 && isNumber(p[0]) && isNumber(p[1]);
      const isLinearRing = (ring) => Array.isArray(ring) && ring.length >= 4 && ring.every(isPosition);
      const isPolygon = (coords) => Array.isArray(coords) && coords.length > 0 && coords.every(isLinearRing);
      const isMultiPolygon = (coords) => Array.isArray(coords) && coords.length > 0 && coords.every(isPolygon);

      function sanitizeFeatureCollection(fcIn) {
        try {
          if (!isFeatureCollection(fcIn)) return null;
          const out = { type: 'FeatureCollection', features: [] };
          for (const feat of fcIn.features || []) {
            if (!feat || typeof feat !== 'object') continue;
            const g = feat.geometry;
            if (!g || typeof g !== 'object') continue;
            if (g.type === 'Polygon' && isPolygon(g.coordinates)) out.features.push(feat);
            else if (g.type === 'MultiPolygon' && isMultiPolygon(g.coordinates)) out.features.push(feat);
          }
          return out.features.length ? out : null;
        } catch {
          return null;
        }
      }

      const toggleRowsLifo = (prevRows, zoneLabel, { addressCount, sample, source }) => {
        const idx = prevRows.findIndex((r) => r.zone === zoneLabel);
        if (idx === 0) return { rows: prevRows.slice(1), toggledOff: true };
        if (idx > 0)  return { rows: [...prevRows.slice(0, idx), ...prevRows.slice(idx + 1)], toggledOff: true };
        const ts = new Date().toISOString();
        return {
          rows: [{ ts, zone: zoneLabel, source: source || 'ne', address_count: addressCount || 0, sample: sample || '' }, ...prevRows],
          toggledOff: false,
        };
      };

      const FALLBACK_FC = {
        type: 'FeatureCollection',
        features: [
          {
            type: 'Feature',
            properties: { tzid: 'UTC (fallback)' },
            geometry: { type: 'Polygon', coordinates: [[[-5, 45], [5, 45], [5, 35], [-5, 35], [-5, 45]]] },
          },
        ],
      };

      // Canonicalize to map-band label (no minutes)
      function canonicalUtc(label) {
        if (!label) return '';
        let s = String(label).trim();
        s = s.replace(/^GMT/i, 'UTC').replace(/\u2212/g, '-');
        const m = s.match(/([Uu][Tt][Cc])?\s*([+-]?)(\d{1,2})(?::?(\d{2}))?/);
        if (!m) return s.startsWith('UTC') ? s : `UTC${s.startsWith('+')||s.startsWith('-') ? '' : '+'}${s}`;
        const sign = m[2] || '+';
        const hh = Math.min(14, Math.max(0, parseInt(m[3], 10)));
        const hSigned = sign === '-' ? -hh : hh;
        return `UTC${hSigned >= 0 ? '+' : ''}${hSigned}`;
      }
      const offsetToLabel = (h) => `UTC${h >= 0 ? '+' : ''}${h}`;

      /* ---------- SQL-IDENTICAL DETECTION ---------- */

      // iana tz example map from your SQL
      const TZ_EXAMPLE = new Map([
        [-12,'Etc/GMT+12'],[-11,'Pacific/Pago_Pago'],[-10,'Pacific/Honolulu'],[-9,'America/Anchorage'],
        [-8,'America/Los_Angeles'],[-7,'America/Denver'],[-6,'America/Chicago'],[-5,'America/New_York'],
        [-4,'America/Halifax'],[-3,'America/Sao_Paulo'],[-2,'America/Noronha'],[-1,'Atlantic/Cape_Verde'],
        [0,'Europe/London'],[1,'Europe/Berlin'],[2,'Europe/Eastern_Europe'],[3,'Europe/Moscow'],
        [4,'Asia/Dubai'],[5,'Asia/Karachi'],[6,'Asia/Dhaka'],[7,'Asia/Bangkok'],[8,'Asia/Singapore'],
        [9,'Asia/Tokyo'],[10,'Australia/Sydney'],[11,'Pacific/Guadalcanal'],[12,'Pacific/Auckland'],
        [13,'Pacific/Tongatapu'],[14,'Pacific/Kiritimati']
      ]);

      const MULT = 5.0;                           // params.mult
      const OFFSETS = Array.from({length: 27}, (_,i)=> i-12); // -12..14
      const HOURS = Array.from({length: 24}, (_,i)=> i);      // 0..23

      function median(arr) {
        if (!arr.length) return 0;
        const a = arr.slice().sort((x,y)=>x-y);
        const mid = Math.floor(a.length/2);
        return a.length % 2 ? a[mid] : (a[mid-1] + a[mid]) / 2;
      }

      // Produce result for ONE address using your SQL rules
      function scoreBySqlRules(counts24) {
        // Precompute map: for each offset and UTC hour, whether mapped local hour is in high/low
        // in_high: local 10..15, in_low: local 1..5
        const map = {};
        for (const o of OFFSETS) {
          map[o] = {};
          for (const h of HOURS) {
            const local = (h + o + 24) % 24;
            map[o][h] = {
              in_high: (local >= 10 && local <= 15),
              in_low : (local >= 1  && local <= 5 )
            };
          }
        }

        // meds: med_10_15 & med_1_5 per offset (median over mapped hours)
        const meds = {};
        for (const o of OFFSETS) {
          const hiVals = [];
          const loVals = [];
          for (const h of HOURS) {
            const c = counts24[h] || 0;
            const m = map[o][h];
            if (m.in_high) hiVals.push(c);
            if (m.in_low ) loVals.push(c);
          }
          const medHi = median(hiVals);
          const medLo = median(loVals);
          meds[o] = { med_10_15: medHi, med_1_5: medLo };
        }

        // bars_over_mult per offset
        const bars = {};
        for (const o of OFFSETS) {
          const { med_1_5 } = meds[o];
          let cnt = 0;
          for (const h of HOURS) {
            const c = counts24[h] || 0;
            if (map[o][h].in_high && c >= MULT * med_1_5) cnt++;
          }
          bars[o] = cnt;
        }

        // scored set per offset
        const scored = OFFSETS.map((o)=> {
          const { med_10_15, med_1_5 } = meds[o];
          const ratio = med_1_5 === 0 ? (med_10_15 > 0 ? Infinity : 0) : (med_10_15 / med_1_5);
          const bars_high_over_mult = bars[o];
          const passes_rule = (med_1_5 > 0 && med_10_15 >= MULT * med_1_5);
          return { offset:o, med_10_15, med_1_5, ratio, bars_high_over_mult, passes_rule };
        });

        // pick best (ratio desc, then bars desc)
        scored.sort((a,b)=>{
          if (a.ratio === b.ratio) return b.bars_high_over_mult - a.bars_high_over_mult;
          // Infinity should win
          if (a.ratio === Infinity) return -1;
          if (b.ratio === Infinity) return 1;
          return b.ratio - a.ratio;
        });

        const best = scored[0] || { offset:0, med_10_15:0, med_1_5:0, ratio:0, bars_high_over_mult:0, passes_rule:false };
        const utc_id = best.offset; // numeric id mirroring SQL
        const label_sql =
          utc_id < 0 ? `UTC - ${Math.abs(utc_id)}` :
          utc_id > 0 ? `UTC + ${utc_id}` :
          'UTC ± 0';
        const iana_tz_example = TZ_EXAMPLE.get(utc_id) || 'Etc/UTC';

        return {
          utc_offset_hours: utc_id,
          utc_id,
          utc_label_sql: label_sql,
          utc_label: offsetToLabel(utc_id),       // canonical (for polygons)
          iana_tz_example,
          ...best
        };
      }

      async function getAllChainIds() {
        try {
          const r = await fetch(`${SIM_BASE}/chains`);
          if (r.ok) {
            const js = await r.json();
            const ids = (js?.chains || js || [])
              .map((c) => Number(c.chain_id ?? c.id))
              .filter((n) => Number.isFinite(n));
            const uniq = Array.from(new Set(ids)).sort((a, b) => a - b);
            if (uniq.length) return uniq;
          }
        } catch {}
        return [
          1, 10, 25, 40, 56, 57, 100, 122, 137, 169, 204, 250, 288, 324, 336, 360, 369, 534, 570, 595, 616, 7700, 8217,
          8453, 9001, 10000, 1030, 1088, 1101, 1284, 1285, 2000, 2222, 4689, 5000, 59140, 59144, 71401, 81457, 42161,
          42170, 42220, 43114, 47805, 50001, 53935
        ];
      }

      async function fetchAddressHourlyCounts(address, chainIds) {
        const counts = new Array(24).fill(0);
        const CONCURRENCY = 6;
        let idx = 0;

        async function worker() {
          while (idx < chainIds.length) {
            const chainId = chainIds[idx++];
            const url =
              `${SIM_BASE}/evm/activity/${address}`
              + `?chain_ids=${chainId}`
              + `&type=send,receive,mint,burn`
              + `&sort_by=block_time&sort_order=asc`;
            try {
              const r = await fetch(url);
              if (!r.ok) continue;
              const { activity = [] } = await r.json();
              for (const ev of activity) {
                const t = Date.parse(ev.block_time);
                if (!Number.isFinite(t)) continue;
                const h = new Date(t).getUTCHours();
                counts[h] += 1;
              }
            } catch {}
          }
        }
        await Promise.all(Array.from({ length: Math.min(CONCURRENCY, chainIds.length) }, () => worker()));
        return counts;
      }

      async function mapWithConcurrency(items, limit, fn) {
        const results = new Array(items.length);
        let i = 0;
        const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
          while (i < items.length) {
            const idx = i++;
            try { results[idx] = await fn(items[idx], idx); }
            catch (e) { results[idx] = { error: e?.message || String(e) }; }
          }
        });
        await Promise.all(workers);
        return results;
      }

      async function detectTimezones(addresses = []) {
        const chainIds = await getAllChainIds();
        const perAddress = await mapWithConcurrency(addresses, 4, async (addr) => {
          const counts = await fetchAddressHourlyCounts(addr, chainIds);
          const scored = scoreBySqlRules(counts);  // <-- SQL-accurate
          return { address: addr, counts, ...scored };
        });
        return perAddress;
      }

      /* ---------- UI (same as before, but uses utc_label from score) ---------- */

      function TimezoneMapUI() {
        const mapEl = useRef(null);
        const mapRef = useRef(null);
        const tzLayerRef = useRef(null);

        const [selectedZones, setSelectedZones] = useState([]); // canonical labels
        const selectedZonesRef = useRef(selectedZones);
        useEffect(() => { selectedZonesRef.current = selectedZones; }, [selectedZones]);

        const [addresses, setAddresses] = useState([]);
        const [addressInput, setAddressInput] = useState('');
        const [rows, setRows] = useState([]);
        const [status, setStatus] = useState('');
        const [loading, setLoading] = useState(false);
        const [detecting, setDetecting] = useState(false);
        const [detectError, setDetectError] = useState('');
        const [zoneAddresses, setZoneAddresses] = useState({});
        const zoneAddressesRef = useRef(zoneAddresses);
        useEffect(() => { zoneAddressesRef.current = zoneAddresses; }, [zoneAddresses]);

        const TOPO_URL = 'https://gist.githubusercontent.com/tschaub/cc70281ce4df5358eac38b34409b9ef9/raw/d152ba9e83d7733d9fb5f37f52202c0fcead834a/timezones.json';
        const [geoData, setGeoData] = useState(FALLBACK_FC);

        const loadScript = (src) => new Promise((resolve, reject) => {
          const existing = document.querySelector(`script[src="${src}"]`);
          if (existing) {
            if (existing.dataset.loaded === 'true') return resolve();
            existing.addEventListener('load', () => resolve());
            existing.addEventListener('error', reject);
            return;
          }
          const s = document.createElement('script'); s.src = src; s.async = true;
          s.onload = () => { s.dataset.loaded = 'true'; resolve(); };
          s.onerror = reject; document.body.appendChild(s);
        });
        const loadCSS = (href) => new Promise((resolve, reject) => {
          const existing = document.querySelector(`link[href="${href}"]`);
          if (existing) return resolve();
          const l = document.createElement('link'); l.rel = 'stylesheet'; l.href = href;
          l.onload = resolve; l.onerror = reject; document.head.appendChild(l);
        });

        useEffect(() => {
          let cancelled = false;
          (async () => {
            try {
              await loadCSS('https://unpkg.com/leaflet@1.9.4/dist/leaflet.css');
              await loadScript('https://unpkg.com/leaflet@1.9.4/dist/leaflet.js');
              if (cancelled) return;
              const L = window.L; if (!L) throw new Error('Leaflet failed to load');

              mapRef.current = L.map(mapEl.current, { minZoom: 1.5, worldCopyJump: true, zoomSnap: 0.25, zoomDelta: 0.25 })
                .setView([20, 0], 2.2);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { opacity: 0.5, attribution: '&copy; OSM' }).addTo(mapRef.current);

              setLoading(true);
              try {
                await loadScript('https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js');
                const r = await fetch(TOPO_URL, { cache: 'reload' });
                if (!r.ok) throw new Error(`Failed to fetch TopoJSON (HTTP ${r.status})`);
                const topo = await r.json();
                const objects = topo && topo.objects ? topo.objects : {};
                const keys = Object.keys(objects);
                if (!keys.length) throw new Error('Invalid TopoJSON: no objects');
                const bestKey = keys.find((k) => /time/i.test(k)) || keys[0];
                const fc = window.topojson.feature(topo, objects[bestKey]);
                const sanitized = sanitizeFeatureCollection(fc);
                if (!sanitized) throw new Error('Converted data is not a valid FeatureCollection');
                setGeoData(sanitized);
                setStatus(`Loaded ${sanitized.features?.length ?? 0} zones.`);
              } catch (err) {
                console.error(err);
                setGeoData(FALLBACK_FC);
                setStatus(`Error loading timezones — showing fallback`);
              } finally {
                setLoading(false);
              }

              renderZones();

              mapRef.current.on('click', (e) => {
                if (!e.originalEvent.target.closest?.('.leaflet-interactive')) setSelectedZones([]);
              });
            } catch (err) {
              console.error(err);
              setStatus(err.message || String(err));
            }
          })();

          return () => { cancelled = true; try { mapRef.current?.remove(); } catch {} };
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);

        useEffect(() => {
          if (!tzLayerRef.current) return;
          try {
            tzLayerRef.current.eachLayer((layer) => {
              const feature = layer.feature || {};
              const original = getZoneName(feature.properties || {});
              const canon = canonicalUtc(original);
              const selected = selectedZones.includes(canon);
              const color = pastelFromLabel(canon);

              layer.setStyle({
                fillColor: selected ? color : 'transparent',
                fillOpacity: selected ? 0.6 : 0,
                color: selected ? color : '#6072a6',
                weight: selected ? 2 : 1,
              });

              const count = zoneAddressesRef.current[canon]?.length || 0;
              layer.bindTooltip(`${canon} · ${count}${original && original !== canon ? ` (${original})` : ''}`, {
                sticky: true, direction: 'top'
              });
            });
          } catch {}
        }, [selectedZones]);

        useEffect(() => { if (mapRef.current) renderZones(); /* eslint-disable-line react-hooks/exhaustive-deps */ }, [geoData]);

        function renderZones() {
          const L = window.L; if (!L || !mapRef.current || !geoData) return;
          if (tzLayerRef.current) {
            try { tzLayerRef.current.remove(); } catch {}
            tzLayerRef.current = null;
          }

          const style = (feature) => {
            const original = getZoneName(feature?.properties || {});
            const canon = canonicalUtc(original);
            const selected = selectedZonesRef.current.includes(canon);
            const color = pastelFromLabel(canon);
            return {
              color: selected ? color : '#6072a6',
              weight: selected ? 2 : 1,
              fillColor: selected ? color : 'transparent',
              fillOpacity: selected ? 0.6 : 0,
            };
          };

          const onEachFeature = (feature, layer) => {
            const original = getZoneName(feature?.properties || {});
            const canon = canonicalUtc(original);
            const count = zoneAddressesRef.current[canon]?.length || 0;
            layer.bindTooltip(`${canon} · ${count}${original && original !== canon ? ` (${original})` : ''}`, {
              sticky: true, direction: 'top'
            });
            layer.on('click', () => {
              setSelectedZones((prev) => {
                const already = prev.includes(canon);
                setRows((prevRows) =>
                  toggleRowsLifo(prevRows, canon, {
                    addressCount: zoneAddressesRef.current[canon]?.length || 0,
                    sample: (zoneAddressesRef.current[canon] || []).join(' | '),
                    source: 'ne',
                  }).rows
                );
                return already ? prev.filter((z) => z !== canon) : [canon, ...prev];
              });
              try { if (layer.getBounds) mapRef.current.fitBounds(layer.getBounds(), { padding: [20, 20] }); } catch {}
            });
          };

          tzLayerRef.current = L.geoJSON(geoData, { style, onEachFeature }).addTo(mapRef.current);
        }

        async function handleDetect(addrList = addresses) {
          if (!addrList.length) return;
          setDetecting(true);
          setDetectError('');
          try {
            const res = await detectTimezones(addrList);

            // Group by canonical map label (utc_label) to color polygons,
            // but keep the SQL-style label in the table.
            const zoneMap = {};
            const tableRows = [];
            for (const r of Array.isArray(res) ? res : []) {
              const canon = canonicalUtc(r.utc_label);
              (zoneMap[canon] = zoneMap[canon] || []).push(r.address);
              tableRows.push({
                ts: new Date().toISOString(),
                zone: r.utc_label_sql,      // show SQL style in table
                source: 'sim',
                address_count: 1,
                sample: r.address
              });
            }

            const zones = Object.keys(zoneMap);
            if (!zones.length) throw new Error('No timezone returned');
            setZoneAddresses(zoneMap);
            setSelectedZones(zones);

            // Aggregate rows by zone for the table (like before)
            const agg = [];
            for (const z of zones) {
              agg.push({
                ts: new Date().toISOString(),
                zone: z, // display canonical here in the table header below; feel free to swap to r.utc_label_sql if preferred
                source: 'sim',
                address_count: zoneMap[z].length,
                sample: zoneMap[z].join(' | ')
              });
            }
            setRows(agg);
            setStatus(`Detected ${addrList.length} address(es) across ${zones.length} zone(s).`);
          } catch (err) {
            console.error(err);
            setDetectError(err.message || 'Timezone detection failed');
          } finally {
            setDetecting(false);
          }
        }

        const handleParse = () => {
          const parsed = parseAddresses(addressInput);
          setAddresses(parsed);
        };

        return (
          <div style={{ maxWidth: 1100, margin: '0 auto', padding: 16, fontFamily: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial', color: '#e8ecff' }}>
            <style>{`
              :root { --card: rgba(255,255,255,0.06); --stroke: rgba(255,255,255,0.12); --text: #e8ecff; --muted:#aab4d6; }
              .fancy-bg { position: fixed; inset: -20vmax; z-index: -1;
                background: radial-gradient(60vmax 60vmax at 20% 10%, #2b5cff22, transparent),
                            radial-gradient(50vmax 50vmax at 80% 30%, #00ffd522, transparent),
                            radial-gradient(40vmax 40vmax at 50% 90%, #ff66cc22, transparent);
                filter: blur(40px); animation: float 16s ease-in-out infinite alternate; }
              @keyframes float { from { transform: translateY(-8px);} to { transform: translateY(8px);} }
              .card { background: var(--card); border: 1px solid var(--stroke); border-radius: 16px;
                box-shadow: 0 20px 60px rgba(0,0,0,.35); backdrop-filter: blur(8px); }
              .btn { border: 0; border-radius: 10px; padding: 10px 14px; cursor: pointer; font-weight: 700;
                transition: transform .12s ease, box-shadow .2s ease; }
              .btn:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,.25); }
              .btn-primary { background: linear-gradient(135deg,#5c7cfa,#4dabf7); color: white; }
              .btn-plain { background: #0b1020; color: var(--text); border: 1px solid var(--stroke); }
              .textarea { width: 100%; height: 140px; background: #081225; color: #e8ecff;
                border: 1px solid var(--stroke); border-radius: 12px; padding: 12px; }
              .pill { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
                border: 1px solid var(--stroke); background: rgba(255,255,255,.05); font-size:12px; }
              .pill button { background: transparent; border: 0; color: #ffffffcc; cursor: pointer; border-radius: 999px; padding: 0 6px; }
              .table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text); }
              .th, .td { padding: 10px 8px; border-bottom: 1px solid rgba(255,255,255,.08); }
              .thead { position: sticky; top: 0; background: #0f1424; z-index: 1; }
            `}</style>

            <div className="fancy-bg" />
            <h1 style={{ margin: 0, fontSize: 28, letterSpacing: .3 }}>
              <span style={{ background: 'linear-gradient(135deg,#91a7ff,#63e6be)', WebkitBackgroundClip: 'text', color: 'transparent', fontWeight: 800 }}>
                UTC Timezones
              </span>
              <span style={{ fontSize: 13, color: '#b6c2ff', fontWeight: 600, opacity: .9, marginLeft: 10 }}>
                real polygons • SQL-accurate detection
              </span>
            </h1>
            <p style={{ marginTop: 6, color: '#c7d0ff', opacity: .85 }}>
              Paste addresses, click a zone to log it, click again to undo the last log for that zone.
            </p>

            <div style={{ display: 'grid', gridTemplateColumns: '1.45fr .55fr', gap: 16, marginTop: 14 }}>
              <div className="card" style={{ padding: 14 }}>
                <div style={{ marginBottom: 10, color: '#c9d2ff', fontWeight: 700, display:'flex', alignItems:'center', justifyContent:'space-between' }}>
                  <span>Map</span>
                  <span style={{ fontSize: 12, color: '#9fb0ff' }}>{loading ? 'Loading timezones…' : status}</span>
                </div>
                <div ref={mapEl} style={{ height: 560, borderRadius: 12, overflow: 'hidden', boxShadow: 'inset 0 0 0 1px rgba(255,255,255,.06)' }} />
                {selectedZones.length > 0 && (
                  <div style={{ marginTop: 10, display:'flex', flexWrap:'wrap', gap:8 }}>
                    {selectedZones.map((z) => (
                      <span key={z} className="pill">
                        <span style={{ width:10, height:10, borderRadius:999, background: pastelFromLabel(z), boxShadow:'0 0 0 2px rgba(0,0,0,.25) inset' }} />
                        {z}
                        <button title="Remove" onClick={() => {
                          setSelectedZones(prev => prev.filter(p => p !== z));
                          setRows(prev => toggleRowsLifo(prev, z, { addressCount: 0, sample: '', source: 'sim' }).rows);
                        }}>×</button>
                      </span>
                    ))}
                  </div>
                )}
              </div>

              <div className="card" style={{ padding: 14 }}>
                <div style={{ marginBottom: 10, color: '#c9d2ff', fontWeight: 700 }}>Addresses</div>
                <textarea
                  className="textarea"
                  value={addressInput}
                  onChange={(e) => setAddressInput(e.target.value)}
                  placeholder="Paste crypto addresses (EVM 0x..., Solana base58). One per line or separated by spaces/commas."
                />
                <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 8 }}>
                  <button className="btn btn-primary" onClick={handleParse} disabled={detecting}>Parse</button>
                  <button className="btn btn-primary" onClick={() => handleDetect()} disabled={!addresses.length || detecting}>Run</button>
                  <span style={{ fontSize: 12, color: '#b9c3e6' }}>
                    {detecting ? 'Detecting timezones…' : `${addresses.length} valid address${addresses.length === 1 ? '' : 'es'}`}
                  </span>
                  {detectError && <span style={{ fontSize: 12, color: '#ff6b6b' }}>{detectError}</span>}
                </div>
              </div>
            </div>

            <div className="card" style={{ marginTop: 18, padding: 12 }}>
              <div style={{ fontWeight: 700, marginBottom: 8, color: '#c9d2ff' }}>Clicks</div>
              <div style={{ overflowX: 'auto' }}>
                <table className="table">
                  <thead>
                    <tr className="thead">
                      <th className="th">Timestamp</th>
                      <th className="th">Timezone</th>
                      <th className="th">Source</th>
                      <th className="th">Address Count</th>
                      <th className="th">Addresses</th>
                    </tr>
                  </thead>
                  <tbody>
                    {rows.length === 0 ? (
                      <tr>
                        <td colSpan={5} style={{ padding: 12, opacity: 0.7 }}>No clicks yet. Paste addresses, then click a timezone.</td>
                      </tr>
                    ) : (
                      rows.map((row, idx) => (
                        <tr key={row.ts + idx} style={{ borderBottom: '1px solid rgba(255,255,255,.06)' }}>
                          <td className="td">{row.ts}</td>
                          <td className="td">{row.zone}</td>
                          <td className="td">{row.source}</td>
                          <td className="td">{row.address_count}</td>
                          <td className="td">{row.sample}</td>
                        </tr>
                      ))
                    )}
                  </tbody>
                </table>
              </div>
            </div>

            <div style={{ marginTop: 8, fontSize: 12, color: '#aab4d6' }}>
              Data: Natural Earth time zones (via TopoJSON). Basemap © OSM contributors. SIM calls via your Cloudflare Worker.
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(TimezoneMapUI));
    </script>
  </body>
</html>
