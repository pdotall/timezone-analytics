<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>UTC Timezones — Map (SIM, SQL-accurate)</title>
  <meta name="description" content="Interactive UTC timezones with SQL-identical prediction logic."/>
  <style>
    html, body { margin: 0; height: 100%; background: #0b1020; }
    #root { min-height: 100vh; }
  </style>
</head>
<body>
<div id="root"></div>

<!-- React via CDN + Babel so we can use JSX inline for a quick demo -->
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<script type="text/babel">
  const { useEffect, useRef, useState } = React;

  /* =======================
     CONFIG
  ======================= */
  const SIM_PROXY = 'https://smart-money.pdotcapital.workers.dev/v1';
  const NE_TOPO_URL =
    'https://gist.githubusercontent.com/tschaub/cc70281ce4df5358eac38b34409b9ef9/raw/d152ba9e83d7733d9fb5f37f52202c0fcead834a/timezones.json';
  const MULT = 5.0;

  const IANA_EXAMPLE = new Map([
    [-12, 'Etc/GMT+12'],
    [-11, 'Pacific/Pago_Pago'],
    [-10, 'Pacific/Honolulu'],
    [ -9, 'America/Anchorage'],
    [ -8, 'America/Los_Angeles'],
    [ -7, 'America/Denver'],
    [ -6, 'America/Chicago'],
    [ -5, 'America/New_York'],
    [ -4, 'America/Halifax'],
    [ -3, 'America/Sao_Paulo'],
    [ -2, 'America/Noronha'],
    [ -1, 'Atlantic/Cape_Verde'],
    [  0, 'Europe/London'],
    [  1, 'Europe/Berlin'],
    [  2, 'Europe/Eastern_Europe'],
    [  3, 'Europe/Moscow'],
    [  4, 'Asia/Dubai'],
    [  5, 'Asia/Karachi'],
    [  6, 'Asia/Dhaka'],
    [  7, 'Asia/Bangkok'],
    [  8, 'Asia/Singapore'],
    [  9, 'Asia/Tokyo'],
    [ 10, 'Australia/Sydney'],
    [ 11, 'Pacific/Guadalcanal'],
    [ 12, 'Pacific/Auckland'],
    [ 13, 'Pacific/Tongatapu'],
    [ 14, 'Pacific/Kiritimati'],
  ]);

  /* =======================
     HELPERS
  ======================= */
  const getZoneName = (props = {}) =>
    props.tzid || props.TZID || props.time_zone || props.NAME || props.name || 'Timezone';

  function polyToUiLabel(raw) {
    if (!raw) return 'UTC ± 0';
    const m = String(raw).match(/UTC\s*([+-])\s*(\d{1,2})/i);
    if (!m) return String(raw).replace('UTC+0','UTC ± 0').replace('UTC-0','UTC ± 0');
    const sign = m[1] === '-' ? '-' : '+';
    const h = String(parseInt(m[2],10));
    if (h === '0') return 'UTC ± 0';
    return `UTC ${sign} ${h}`;
  }
  function offsetToUiLabel(offset) {
    if (offset === 0) return 'UTC ± 0';
    if (offset > 0)  return `UTC + ${offset}`;
    return `UTC - ${Math.abs(offset)}`;
  }

  const pastelFromLabel = (label) => {
    let h = 0;
    const s = String(label || '');
    for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
    const hue = h % 360;
    return `hsl(${hue} 85% 70%)`;
  };

  const isFeatureCollection = (obj) => !!obj && obj.type === 'FeatureCollection' && Array.isArray(obj.features);
  const isNumber = (x) => typeof x === 'number' && Number.isFinite(x);
  const isPosition = (p) => Array.isArray(p) && p.length >= 2 && isNumber(p[0]) && isNumber(p[1]);
  const isLinearRing = (ring) => Array.isArray(ring) && ring.length >= 4 && ring.every(isPosition);
  const isPolygon = (coords) => Array.isArray(coords) && coords.length > 0 && coords.every(isLinearRing);
  const isMultiPolygon = (coords) => Array.isArray(coords) && coords.length > 0 && coords.every(isPolygon);

  function sanitizeFeatureCollection(fcIn) {
    try {
      if (!isFeatureCollection(fcIn)) return null;
      const out = { type: 'FeatureCollection', features: [] };
      for (const feat of fcIn.features || []) {
        if (!feat || typeof feat !== 'object') continue;
        const g = feat.geometry;
        if (!g || typeof g !== 'object') continue;
        if (g.type === 'Polygon' && isPolygon(g.coordinates)) out.features.push(feat);
        else if (g.type === 'MultiPolygon' && isMultiPolygon(g.coordinates)) out.features.push(feat);
      }
      return out.features.length ? out : null;
    } catch {
      return null;
    }
  }

  const FALLBACK_FC = {
    type: 'FeatureCollection',
    features: [{
      type: 'Feature',
      properties: { tzid: 'UTC ± 0 (fallback)' },
      geometry: { type: 'Polygon', coordinates: [[[-5,45],[5,45],[5,35],[-5,35],[-5,45]]] }
    }]
  };

  const isEvm = (s) => /^(0x)[0-9a-fA-F]{40}$/.test(s);
  const isSol = (s) => /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(s);
  const parseAddresses = (text) => {
    const parts = String(text || '')
      .split(/[\s,;\n\r]+/)
      .map((s) => s.trim())
      .filter(Boolean);
    const seen = new Set();
    const out = [];
    for (const addr of parts) {
      let key = null;
      if (isEvm(addr)) key = addr.toLowerCase();
      else if (isSol(addr)) continue;
      else continue;
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(addr);
    }
    return out;
  };

  function median(values) {
    if (!values || values.length === 0) return null;
    const arr = values.slice().sort((a,b)=>a-b);
    const n = arr.length;
    const mid = Math.floor(n/2);
    if (n % 2 === 1) return arr[mid];
    return (arr[mid-1] + arr[mid]) / 2;
  }

  function buildHourMap() {
    const map = new Map();
    for (let offset=-12; offset<=14; offset++) {
      const high = new Set();
      const low  = new Set();
      for (let h=0; h<24; h++) {
        const local = (h + offset + 24) % 24;
        if (local >= 10 && local <= 15) high.add(h);
        if (local >= 1  && local <= 5)  low.add(h);
      }
      map.set(offset, {high, low});
    }
    return map;
  }
  const HOUR_MAP = buildHourMap();

  async function fetchTxHoursForAddress(address, cap=3000) {
    let offset = null;
    let fetched = 0;
    const counts = new Map();

    while (true) {
      const q = new URL(`${SIM_PROXY}/evm/transactions/${address}`);
      q.searchParams.set('limit', '500');
      if (offset) q.searchParams.set('offset', offset);

      const r = await fetch(q.toString(), { headers: { 'Accept': 'application/json' } });
      if (!r.ok) throw new Error(`SIM /transactions HTTP ${r.status}`);
      const js = await r.json();
      const txs = Array.isArray(js.transactions) ? js.transactions : [];
      for (const t of txs) {
        const d = new Date(t.block_time);
        const h = d.getUTCHours();
        counts.set(h, (counts.get(h) || 0) + 1);
      }
      fetched += txs.length;
      offset = js.next_offset || null;
      if (!offset || fetched >= cap || txs.length === 0) break;
    }

    return counts;
  }

  function predictTimezoneFromCountsSQL(countMap) {
    let best = null;

    for (let offset=-12; offset<=14; offset++) {
      const { high, low } = HOUR_MAP.get(offset);

      const highVals = [];
      const lowVals  = [];
      for (const h of high) { if (countMap.has(h)) highVals.push(countMap.get(h)); }
      for (const h of low)  { if (countMap.has(h))  lowVals.push(countMap.get(h)); }

      const med_10_15 = median(highVals);
      const med_1_5   = median(lowVals);
      let ratio = null;
      if (med_1_5 !== null && med_1_5 !== 0) ratio = med_10_15 !== null ? (med_10_15 / med_1_5) : null;

      let bars_high_over_mult = 0;
      if (med_1_5 !== null && med_1_5 !== 0) {
        const thresh = MULT * med_1_5;
        for (const h of high) {
          const v = countMap.get(h);
          if (typeof v === 'number' && v >= thresh) bars_high_over_mult++;
        }
      }

      const passes_rule = (med_1_5 !== null && med_1_5 > 0) &&
                          (med_10_15 !== null && med_10_15 >= MULT * med_1_5);

      const row = { offset, med_10_15, med_1_5, ratio, bars_high_over_mult, passes_rule };

      const better = (() => {
        if (!best) return true;
        const a = row, b = best;
        if (a.ratio === null && b.ratio === null) {
          if (a.bars_high_over_mult !== b.bars_high_over_mult) {
            return a.bars_high_over_mult > b.bars_high_over_mult;
          }
          return false;
        }
        if (a.ratio === null) return false;
        if (b.ratio === null) return true;
        if (a.ratio !== b.ratio) return a.ratio > b.ratio;
        if (a.bars_high_over_mult !== b.bars_high_over_mult) {
          return a.bars_high_over_mult > b.bars_high_over_mult;
        }
        return false;
      })();

      if (better) best = row;
    }

    const offset = best?.offset ?? 0;
    return {
      utc_offset_hours: offset,
      utc_label: offsetToUiLabel(offset),
      iana_tz_example: IANA_EXAMPLE.get(offset) || 'Etc/UTC',
      passes_rule: !!best?.passes_rule,
      med_10_15: best?.med_10_15 ?? null,
      med_1_5: best?.med_1_5 ?? null,
      ratio: best?.ratio ?? null,
      bars_high_over_mult: best?.bars_high_over_mult ?? 0
    };
  }

  function App() {
    const mapEl = useRef(null);
    const mapRef = useRef(null);
    const tzLayerRef = useRef(null);

    const [selectedZones, setSelectedZones] = useState([]);
    const selectedZonesRef = useRef(selectedZones);
    useEffect(() => { selectedZonesRef.current = selectedZones; }, [selectedZones]);

    const [addresses, setAddresses] = useState([]);
    const [addressInput, setAddressInput] = useState('');
    const [status, setStatus] = useState('');
    const [loading, setLoading] = useState(false);
    const [detecting, setDetecting] = useState(false);
    const [detectError, setDetectError] = useState('');

    // map of zone -> addresses (for group counts & chips)
    const [zoneAddresses, setZoneAddresses] = useState({});
    const zoneAddressesRef = useRef(zoneAddresses);
    useEffect(()=>{ zoneAddressesRef.current = zoneAddresses; }, [zoneAddresses]);

    // NEW: per-address results for the results table
    const [results, setResults] = useState([]);

    const [geoData, setGeoData] = useState(FALLBACK_FC);

    const loadScript = (src) => new Promise((resolve,reject)=>{
      const existing = document.querySelector(`script[src="${src}"]`);
      if (existing) {
        if (existing.dataset.loaded === 'true') return resolve();
        existing.addEventListener('load', () => resolve());
        existing.addEventListener('error', reject);
        return;
      }
      const s = document.createElement('script');
      s.src = src; s.async = true;
      s.onload = () => { s.dataset.loaded = 'true'; resolve(); };
      s.onerror = reject; document.body.appendChild(s);
    });
    const loadCSS = (href) => new Promise((resolve,reject)=>{
      const existing = document.querySelector(`link[href="${href}"]`);
      if (existing) return resolve();
      const l = document.createElement('link');
      l.rel ='stylesheet'; l.href=href;
      l.onload = resolve; l.onerror = reject; document.head.appendChild(l);
    });

    useEffect(() => {
      (async () => {
        try {
          await loadCSS('https://unpkg.com/leaflet@1.9.4/dist/leaflet.css');
          await loadScript('https://unpkg.com/leaflet@1.9.4/dist/leaflet.js');
          const L = window.L; if (!L) throw new Error('Leaflet failed to load');

          mapRef.current = L.map(mapEl.current, {
            minZoom: 1.5, worldCopyJump: true, zoomSnap: 0.25, zoomDelta: 0.25
          }).setView([20, 0], 2.2);

          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            opacity: 0.5, attribution: '&copy; OSM'
          }).addTo(mapRef.current);

          await loadScript('https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js');
          await loadZones();
          renderZones();

          mapRef.current.on('click', (e) => {
            if (!e.originalEvent.target.closest?.('.leaflet-interactive')) setSelectedZones([]);
          });
        } catch (err) {
          console.error(err);
          setStatus(err.message || String(err));
        }
      })();
      return () => { try { mapRef.current?.remove(); } catch {} };
    }, []);

    useEffect(() => {
      if (!tzLayerRef.current) return;
      try {
        tzLayerRef.current.eachLayer((layer) => {
          const feature = layer.feature || {};
          const raw = getZoneName(feature.properties || {});
          const label = polyToUiLabel(raw);
          const selected = selectedZones.includes(label);
          layer.setStyle({
            fillColor: selected ? pastelFromLabel(label) : 'transparent',
            fillOpacity: selected ? 0.6 : 0,
            color: selected ? pastelFromLabel(label) : '#6072a6',
            weight: selected ? 2 : 1,
          });
          layer.bindTooltip(`${label} · ${(zoneAddressesRef.current[label] || []).length}`, { sticky: true, direction: 'top' });
        });
      } catch {}
    }, [selectedZones]);

    useEffect(() => { if (mapRef.current) renderZones(); }, [geoData]);

    async function loadZones() {
      setLoading(true);
      try {
        const r = await fetch(NE_TOPO_URL, { cache: 'reload' });
        if (!r.ok) throw new Error(`NE TopoJSON HTTP ${r.status}`);
        const topo = await r.json();
        const objects = topo?.objects || {};
        const keys = Object.keys(objects);
        if (!keys.length) throw new Error('NE TopoJSON: no objects');
        const bestKey = keys.find((k)=>/time/i.test(k)) || keys[0];
        const fc = window.topojson.feature(topo, objects[bestKey]);
        const sanitized = sanitizeFeatureCollection(fc);
        if (!sanitized) throw new Error('Converted NE data invalid FeatureCollection');
        setGeoData(sanitized);
        setStatus(`Loaded ${sanitized.features?.length ?? 0} time zones.`);
      } catch (err) {
        console.error(err);
        setGeoData(FALLBACK_FC);
        setStatus('All loads failed — showing fallback polygon.');
      } finally {
        setLoading(false);
      }
    }

    function renderZones() {
      const L = window.L; if (!L || !mapRef.current || !geoData) return;
      if (tzLayerRef.current) { try { tzLayerRef.current.remove(); } catch {} tzLayerRef.current = null; }

      const style = (feature) => {
        const raw = getZoneName(feature?.properties || {});
        const label = polyToUiLabel(raw);
        const selected = selectedZonesRef.current.includes(label);
        return {
          color: selected ? pastelFromLabel(label) : '#6072a6',
          weight: selected ? 2 : 1,
          fillColor: selected ? pastelFromLabel(label) : 'transparent',
          fillOpacity: selected ? 0.6 : 0
        };
      };

      const onEachFeature = (feature, layer) => {
        const raw = getZoneName(feature?.properties || {});
        const label = polyToUiLabel(raw);
        layer.bindTooltip(`${label} · ${(zoneAddressesRef.current[label] || []).length}`, { sticky: true, direction: 'top' });
        layer.on('click', () => {
          setSelectedZones((prev) => {
            const already = prev.includes(label);
            return already ? prev.filter((z)=>z!==label) : [label, ...prev];
          });
          try { if (layer.getBounds) mapRef.current.fitBounds(layer.getBounds(), { padding: [20,20] }); } catch {}
        });
      };

      tzLayerRef.current = L.geoJSON(geoData, { style, onEachFeature }).addTo(mapRef.current);
    }

    async function handleDetect(addrList = addresses) {
      if (!addrList.length) return;
      setDetecting(true);
      setDetectError('');
      try {
        const zoneMap = {};
        const perAddress = [];

        for (const addr of addrList) {
          const counts = await fetchTxHoursForAddress(addr, 4000);
          const res = predictTimezoneFromCountsSQL(counts);
          const label = res.utc_label; // "UTC - 3", etc.
          (zoneMap[label] = zoneMap[label] || []).push(addr);
          perAddress.push({
            address: addr,
            utc_label: res.utc_label,
            iana: res.iana_tz_example
          });
        }

        const zones = Object.keys(zoneMap);
        if (!zones.length) throw new Error('No timezone returned');

        setZoneAddresses(zoneMap);        // for group counts & chips
        setSelectedZones(zones);          // color polygons
        setResults(perAddress);           // NEW: per-address table
      } catch (err) {
        console.error(err);
        setDetectError(err.message || 'Timezone detection failed');
      } finally {
        setDetecting(false);
      }
    }

    const handleParse = () => {
      const parsed = parseAddresses(addressInput);
      setAddresses(parsed);
    };

    // helper to get group count per row
    const groupCount = (label) => (zoneAddresses[label] || []).length || 0;

    return (
      <div style={{ maxWidth: 1100, margin: '0 auto', padding: 16, fontFamily: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial', color: '#e8ecff' }}>
        <style>{`
          :root { --card: rgba(255,255,255,0.06); --stroke: rgba(255,255,255,0.12); --text: #e8ecff; --muted:#aab4d6; }
          .fancy-bg { position: fixed; inset: -20vmax; z-index: -1; background:
            radial-gradient(60vmax 60vmax at 20% 10%, #2b5cff22, transparent),
            radial-gradient(50vmax 50vmax at 80% 30%, #00ffd522, transparent),
            radial-gradient(40vmax 40vmax at 50% 90%, #ff66cc22, transparent);
            filter: blur(40px); animation: float 16s ease-in-out infinite alternate; }
          @keyframes float { from { transform: translateY(-8px);} to { transform: translateY(8px);} }
          .card { background: var(--card); border: 1px solid var(--stroke); border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,.35); backdrop-filter: blur(8px); }
          .btn { border: 0; border-radius: 10px; padding: 10px 14px; cursor: pointer; font-weight: 700;
            transition: transform .12s ease, box-shadow .2s ease; }
          .btn:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,.25); }
          .btn-primary { background: linear-gradient(135deg,#5c7cfa,#4dabf7); color: white; }
          .btn-plain { background: #0b1020; color: var(--text); border: 1px solid var(--stroke); }
          .textarea { width: 100%; height: 140px; background: #081225; color: var(--text);
            border: 1px solid var(--stroke); border-radius: 12px; padding: 12px; }
          .pill { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
            border: 1px solid var(--stroke); background: rgba(255,255,255,.05); font-size:12px; }
          .pill button { background: transparent; border: 0; color: #ffffffcc; cursor: pointer; border-radius: 999px; padding: 0 6px; }
          .table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text); }
          .th, .td { padding: 10px 8px; border-bottom: 1px solid rgba(255,255,255,.08); }
          .thead { position: sticky; top: 0; background: #0f1424; z-index: 1; }
          .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        `}</style>

        <div className="fancy-bg" />
        <h1 style={{ margin: 0, fontSize: 28, letterSpacing: .3 }}>
          <span style={{ background: 'linear-gradient(135deg,#91a7ff,#63e6be)', WebkitBackgroundClip: 'text', color: 'transparent', fontWeight: 800 }}>
            UTC Timezones
          </span>
          <span style={{ fontSize: 13, color: '#b6c2ff', fontWeight: 600, opacity: .9, marginLeft: 10 }}>
            real polygons • SQL-identical predictor
          </span>
        </h1>
        <p style={{ marginTop: 6, color: '#c7d0ff', opacity: .85 }}>
          Paste addresses, click a zone to color. “Count” shows how many addresses share that timezone.
        </p>

        <div style={{ display: 'grid', gridTemplateColumns: '1.45fr .55fr', gap: 16, marginTop: 14 }}>
          {/* Map */}
          <div className="card" style={{ padding: 14 }}>
            <div style={{ marginBottom: 10, color: '#c9d2ff', fontWeight: 700, display:'flex', alignItems:'center', justifyContent:'space-between' }}>
              <span>Map</span>
              <span style={{ fontSize: 12, color: '#9fb0ff' }}>{loading ? 'Loading timezones…' : status}</span>
            </div>
            <div ref={mapEl} style={{ height: 560, borderRadius: 12, overflow: 'hidden', boxShadow: 'inset 0 0 0 1px rgba(255,255,255,.06)' }} />
            {selectedZones.length > 0 && (
              <div style={{ marginTop: 10, display:'flex', flexWrap:'wrap', gap:8 }}>
                {selectedZones.map((z) => (
                  <span key={z} className="pill">
                    <span style={{ width:10, height:10, borderRadius:999, background: pastelFromLabel(z), boxShadow:'0 0 0 2px rgba(0,0,0,.25) inset' }} />
                    {z}
                    <button title="Remove" onClick={() => {
                      setSelectedZones(prev => prev.filter(p => p !== z));
                    }}>×</button>
                  </span>
                ))}
              </div>
            )}
          </div>

          {/* Address panel */}
          <div className="card" style={{ padding: 14 }}>
            <div style={{ marginBottom: 10, color: '#c9d2ff', fontWeight: 700 }}>Addresses</div>
            <textarea
              className="textarea"
              value={addressInput}
              onChange={(e) => setAddressInput(e.target.value)}
              placeholder="Paste EVM addresses (0x...). One per line or separated by spaces/commas."
            />
            <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 8 }}>
              <button className="btn btn-primary" onClick={handleParse} disabled={detecting}>Parse</button>
              <button className="btn btn-primary" onClick={() => handleDetect()} disabled={!addresses.length || detecting}>
                Run
              </button>
              <span style={{ fontSize: 12, color: '#b9c3e6' }}>
                {detecting ? 'Detecting timezones…' : `${addresses.length} valid address${addresses.length === 1 ? '' : 'es'}`}
              </span>
              {detectError && <span style={{ fontSize: 12, color: '#ff6b6b' }}>{detectError}</span>}
            </div>
          </div>
        </div>

        {/* Results (per address) */}
        <div className="card" style={{ marginTop: 18, padding: 12 }}>
          <div style={{ fontWeight: 700, marginBottom: 8, color: '#c9d2ff' }}>Results</div>
          <div style={{ overflowX: 'auto' }}>
            <table className="table">
              <thead>
                <tr className="thead">
                  <th className="th">Address</th>
                  <th className="th">Timezone</th>
                  <th className="th">Timezone Name</th>
                  <th className="th">Count</th>
                </tr>
              </thead>
              <tbody>
              {results.length === 0 ? (
                <tr><td colSpan={4} style={{ padding: 12, opacity: 0.7 }}>No results yet. Paste addresses, then click Run.</td></tr>
              ) : results.map((r, i) => (
                <tr key={r.address + i} style={{ borderBottom: '1px solid rgba(255,255,255,.06)' }}>
                  <td className="td mono">{r.address}</td>
                  <td className="td">{r.utc_label}</td>
                  <td className="td">{r.iana}</td>
                  <td className="td">{groupCount(r.utc_label)}</td>
                </tr>
              ))}
              </tbody>
            </table>
          </div>
        </div>

        <div style={{ marginTop: 8, fontSize: 12, color: '#aab4d6' }}>
          Data: Natural Earth time zones (TopoJSON). EVM transactions via SIM (all chains). Basemap © OSM contributors.
        </div>
      </div>
    );
  }

  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App />);
</script>
</body>
</html>
