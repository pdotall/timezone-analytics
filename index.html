<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>UTC Timezones — Demo</title>
    <meta name="description" content="Interactive UTC timezones with real polygons." />
    <style>
      html, body { margin: 0; height: 100%; background: #0b1020; }
      #root { min-height: 100vh; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React via CDN + Babel so we can use JSX inline for a quick demo -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      // Use React globals from the CDN (no imports/exports in this inline script)
      const { useEffect, useRef, useState } = React;

      // === Component code (same as src/TimezoneMapUI.jsx) ===

      const getZoneName = (props = {}) => props.tzid || props.TZID || props.time_zone || props.NAME || props.name || 'Timezone';
      const isEvm = (s) => /^(0x)[0-9a-fA-F]{40}$/.test(s);
      const isSol = (s) => /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(s); // rough base58
      const parseAddresses = (text) => {
        const parts = String(text || '')
          .split(/[\s,;\n\r]+/)
          .map((s) => s.trim())
          .filter(Boolean);
        const seen = new Set();
        const out = [];
        for (const addr of parts) {
          let key = null;
          if (isEvm(addr)) key = addr.toLowerCase();
          else if (isSol(addr)) key = addr;
          else continue;
          if (seen.has(key)) continue;
          seen.add(key);
          out.push(addr);
        }
        return out;
      };

      // -------- FIX: choose the correct API base during dev vs prod --------
      const API_BASE =
        (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
          ? 'http://localhost:3001'
          : '';

      async function detectTimezones(addresses = []) {
        const r = await fetch(`${API_BASE}/api/timezone`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ addresses }),
        });
        if (!r.ok) throw new Error(`API HTTP ${r.status}`);
        return r.json();
      }

      // Pretty color per zone label
      const pastelFromLabel = (label) => {
        let h = 0;
        const s = String(label || '');
        for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
        const hue = h % 360;
        return `hsl(${hue} 85% 70%)`;
      };

      const isFeatureCollection = (obj) => !!obj && obj.type === 'FeatureCollection' && Array.isArray(obj.features);

      // Validate/sanitize geometries (Polygon/MultiPolygon only)
      const isNumber = (x) => typeof x === 'number' && Number.isFinite(x);
      const isPosition = (p) => Array.isArray(p) && p.length >= 2 && isNumber(p[0]) && isNumber(p[1]);
      const isLinearRing = (ring) => Array.isArray(ring) && ring.length >= 4 && ring.every(isPosition);
      const isPolygon = (coords) => Array.isArray(coords) && coords.length > 0 && coords.every(isLinearRing);
      const isMultiPolygon = (coords) => Array.isArray(coords) && coords.length > 0 && coords.every(isPolygon);

      function sanitizeFeatureCollection(fcIn) {
        try {
          if (!isFeatureCollection(fcIn)) return null;
          const out = { type: 'FeatureCollection', features: [] };
          for (const feat of fcIn.features || []) {
            if (!feat || typeof feat !== 'object') continue;
            const g = feat.geometry;
            if (!g || typeof g !== 'object') continue;
            if (g.type === 'Polygon' && isPolygon(g.coordinates)) {
              out.features.push(feat);
            } else if (g.type === 'MultiPolygon' && isMultiPolygon(g.coordinates)) {
              out.features.push(feat);
            }
          }
          return out.features.length ? out : null;
        } catch {
          return null;
        }
      }

      // Add/Toggle rows (LIFO remove for same zone)
      const toggleRowsLifo = (prevRows, zoneLabel, { addressCount, sample, source }) => {
        const idx = prevRows.findIndex((r) => r.zone === zoneLabel); // most recent at 0
        if (idx === 0) return { rows: prevRows.slice(1), toggledOff: true };
        if (idx > 0)  return { rows: [...prevRows.slice(0, idx), ...prevRows.slice(idx + 1)], toggledOff: true };
        const ts = new Date().toISOString();
        return {
          rows: [{ ts, zone: zoneLabel, source: source || 'ne', address_count: addressCount || 0, sample: sample || '' }, ...prevRows],
          toggledOff: false,
        };
      };

      // Fallback FC (so the map always has valid data)
      const FALLBACK_FC = {
        type: 'FeatureCollection',
        features: [
          {
            type: 'Feature',
            properties: { tzid: 'UTC+0 (fallback)' },
            geometry: {
              type: 'Polygon',
              coordinates: [[[-5, 45], [5, 45], [5, 35], [-5, 35], [-5, 45]]],
            },
          },
        ],
      };

      function TimezoneMapUI() {
        const mapEl = useRef(null);
        const mapRef = useRef(null);
        const tzLayerRef = useRef(null);

        const [selectedZones, setSelectedZones] = useState([]); // array of labels
        const selectedZonesRef = useRef(selectedZones);
        useEffect(() => { selectedZonesRef.current = selectedZones; }, [selectedZones]);

        const [addresses, setAddresses] = useState([]);
        const [addressInput, setAddressInput] = useState('');
        const [rows, setRows] = useState([]);
        const [status, setStatus] = useState('');
        const [loading, setLoading] = useState(false);
        const [testResults, setTestResults] = useState(null);
        const [detecting, setDetecting] = useState(false);
        const [detectError, setDetectError] = useState('');
        const [zoneAddresses, setZoneAddresses] = useState({});
        const zoneAddressesRef = useRef(zoneAddresses);
        useEffect(() => { zoneAddressesRef.current = zoneAddresses; }, [zoneAddresses]);

        // Natural Earth TopoJSON → convert to GeoJSON in-browser
        const TOPO_URL = 'https://gist.githubusercontent.com/tschaub/cc70281ce4df5358eac38b34409b9ef9/raw/d152ba9e83d7733d9fb5f37f52202c0fcead834a/timezones.json';

        const [geoData, setGeoData] = useState(FALLBACK_FC); // start with fallback

        // --- External loaders ---
        const loadScript = (src) => new Promise((resolve, reject) => {
          const existing = document.querySelector(`script[src="${src}"]`);
          if (existing) {
            if (existing.dataset.loaded === 'true') return resolve();
            existing.addEventListener('load', () => resolve());
            existing.addEventListener('error', reject);
            return;
          }
          const s = document.createElement('script'); s.src = src; s.async = true;
          s.onload = () => { s.dataset.loaded = 'true'; resolve(); };
          s.onerror = reject; document.body.appendChild(s);
        });
        const loadCSS = (href) => new Promise((resolve, reject) => {
          const existing = document.querySelector(`link[href="${href}"]`);
          if (existing) return resolve();
          const l = document.createElement('link'); l.rel = 'stylesheet'; l.href = href;
          l.onload = resolve; l.onerror = reject; document.head.appendChild(l);
        });

        // --- Map init ---
        useEffect(() => {
          let cancelled = false;
          (async () => {
            try {
              await loadCSS('https://unpkg.com/leaflet@1.9.4/dist/leaflet.css');
              await loadScript('https://unpkg.com/leaflet@1.9.4/dist/leaflet.js');
              if (cancelled) return;
              const L = window.L; if (!L) throw new Error('Leaflet failed to load');
              mapRef.current = L.map(mapEl.current, { minZoom: 1.5, worldCopyJump: true, zoomSnap: 0.25, zoomDelta: 0.25 })
                .setView([20, 0], 2.2);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { opacity: 0.5, attribution: '&copy; OSM' }).addTo(mapRef.current);
              // First data load
              await loadZones();
              // Render initial layer
              renderZones();
              // Clear selection if click on empty map
              mapRef.current.on('click', (e) => {
                if (!e.originalEvent.target.closest?.('.leaflet-interactive')) setSelectedZones([]);
              });
            } catch (err) {
              console.error(err);
              setStatus(err.message || String(err));
            }
          })();
          return () => { cancelled = true; try { mapRef.current?.remove(); } catch {} };
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);

        // Re-style polygons whenever selection changes
        useEffect(() => {
          if (!tzLayerRef.current) return;
          try {
            tzLayerRef.current.eachLayer((layer) => {
              const feature = layer.feature || {}; const label = getZoneName(feature.properties || {});
              const selected = selectedZones.includes(label);
              layer.setStyle({
                fillColor: selected ? pastelFromLabel(label) : 'transparent',
                fillOpacity: selected ? 0.6 : 0,
                color: selected ? pastelFromLabel(label) : '#6072a6',
                weight: selected ? 2 : 1,
              });
              layer.bindTooltip(
                `${label} · ${(zoneAddressesRef.current[label] || []).length}`,
                { sticky: true, direction: 'top' }
              );
            });
          } catch {}
        }, [selectedZones]);

        // Re-render polygons when geoData changes
        useEffect(() => { if (mapRef.current) renderZones(); /* eslint-disable-line react-hooks/exhaustive-deps */ }, [geoData]);

        // Load zones (TopoJSON → FC → sanitize)
        async function loadZones() {
          setLoading(true);
          try {
            await loadScript('https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js');
            const r = await fetch(TOPO_URL, { cache: 'reload' });
            if (!r.ok) throw new Error(`Failed to fetch TopoJSON (HTTP ${r.status})`);
            const topo = await r.json();
            const objects = topo && topo.objects ? topo.objects : {};
            const keys = Object.keys(objects);
            if (!keys.length) throw new Error('Invalid TopoJSON: no objects');
            const bestKey = keys.find((k) => /time/i.test(k)) || keys[0];
            const fc = window.topojson.feature(topo, objects[bestKey]);
            const sanitized = sanitizeFeatureCollection(fc);
            if (!sanitized) throw new Error('Converted data is not a valid FeatureCollection');
            setGeoData(sanitized);
            setStatus(`Loaded ${sanitized.features?.length ?? 0} zones.`);
          } catch (err) {
            console.error(err);
            setGeoData(FALLBACK_FC); // keep fallback
            setStatus(`Error loading timezones — showing fallback: ${err.message || String(err)}`);
          } finally {
            setLoading(false);
          }
        }

        function renderZones() {
          const L = window.L; if (!L || !mapRef.current || !geoData) return;
          // Remove old layer
          if (tzLayerRef.current) {
            try { tzLayerRef.current.remove(); } catch {}
            tzLayerRef.current = null;
          }
          const defaultStyle = (feature) => {
            const label = getZoneName(feature?.properties || {});
            const selected = selectedZonesRef.current.includes(label);
            return { color: selected ? pastelFromLabel(label) : '#6072a6', weight: selected ? 2 : 1, fillColor: selected ? pastelFromLabel(label) : 'transparent', fillOpacity: selected ? 0.6 : 0 };
          };
          const onEachFeature = (feature, layer) => {
            const label = getZoneName(feature?.properties || {});
            layer.bindTooltip(
              `${label} · ${(zoneAddressesRef.current[label] || []).length}`,
              { sticky: true, direction: 'top' }
            );
            layer.on('click', () => {
              setSelectedZones((prev) => {
                const already = prev.includes(label);
                setRows((prevRows) =>
                  toggleRowsLifo(prevRows, label, {
                    addressCount: zoneAddressesRef.current[label]?.length || 0,
                    sample: (zoneAddressesRef.current[label] || []).join(' | '),
                    source: 'ne',
                  }).rows
                );
                return already ? prev.filter((z) => z !== label) : [label, ...prev];
              });
              // Fit bounds
              try { if (layer.getBounds) mapRef.current.fitBounds(layer.getBounds(), { padding: [20, 20] }); } catch {}
            });
          };
          tzLayerRef.current = L.geoJSON(geoData, { style: defaultStyle, onEachFeature }).addTo(mapRef.current);
        }

        async function handleDetect(addrList = addresses) {
          if (!addrList.length) return;
          setDetecting(true);
          setDetectError('');
          try {
            const res = await detectTimezones(addrList);
            const zoneMap = {};
            for (const r of Array.isArray(res) ? res : []) {
              const z = r.utc_label || r.tzid || r.zone || r.utc_zone;
              if (!z) continue;
              (zoneMap[z] = zoneMap[z] || []).push(r.address);
            }
            const zones = Object.keys(zoneMap);
            if (!zones.length) throw new Error('No timezone returned');
            setZoneAddresses(zoneMap);
            setSelectedZones(zones);
            setRows(() => {
              let rows = [];
              for (const z of zones) {
                rows = toggleRowsLifo(rows, z, {
                  addressCount: zoneMap[z].length,
                  sample: zoneMap[z].join(' | '),
                  source: 'api',
                }).rows;
              }
              return rows;
            });
          } catch (err) {
            console.error(err);
            setDetectError(err.message || 'Timezone detection failed');
          } finally {
            setDetecting(false);
          }
        }

        const handleParse = () => {
          const parsed = parseAddresses(addressInput);
          setAddresses(parsed);
        };

        // -------------- Test runner (adds tests) --------------
        function runTests() {
          const results = [];
          try {
            // Test 1: address parsing (EVM + Solana; dedupe; ignore junk)
            const parsed = parseAddresses('0x0000000000000000000000000000000000000000\nfoo\n1BoatSLRHtKNngkdXEeobR76b53LETtpyT\n0x0000000000000000000000000000000000000000');
            results.push(['Parse EVM + Sol + dedupe', parsed.length >= 2 && parsed[0] !== parsed[1]]);

            // Test 2: LIFO toggle rows (add then remove same zone)
            const r1 = toggleRowsLifo([], 'UTC+1', { addressCount: 2, sample: 'a|b', source: 'ne' });
            const r2 = toggleRowsLifo(r1.rows, 'UTC+1', { addressCount: 2, sample: 'a|b', source: 'ne' });
            results.push(['Toggle add then remove', r1.rows.length === 1 && r2.rows.length === 0]);

            // Test 3: FeatureCollection validator
            results.push(['FALLBACK_FC is FeatureCollection', isFeatureCollection(FALLBACK_FC) === true]);
            results.push(['Invalid object rejected', isFeatureCollection({ type: 'Feature', features: [] }) === false]);

            // Test 4: Sanitizer drops invalid geometries & preserves valid
            const dirty = {
              type: 'FeatureCollection',
              features: [
                { type: 'Feature', properties: { tzid: 'bad' }, geometry: { type: 'Polygon', coordinates: [[[NaN, 0],[0,0],[0,1],[NaN,0]]] } },
                { type: 'Feature', properties: { tzid: 'ok' },  geometry: { type: 'Polygon', coordinates: [[[0,0],[1,0],[1,1],[0,1],[0,0]]] } },
              ],
            };
            const clean = sanitizeFeatureCollection(dirty);
            results.push(['Sanitizer keeps only valid feature', isFeatureCollection(clean) && clean.features.length === 1 && getZoneName(clean.features[0].properties) === 'ok']);

            // Test 5: Default style reflects selection
            const selected = ['UTC+2'];
            const styleFrom = (feature) => {
              const label = getZoneName(feature?.properties || {});
              return { fillColor: selected.includes(label) ? 'orange' : 'transparent' };
            };
            const sOk = styleFrom({ properties: { tzid: 'UTC+2' } }).fillColor === 'orange';
            const uOk = styleFrom({ properties: { tzid: 'UTC+3' } }).fillColor === 'transparent';
            results.push(['Style reacts to selection', sOk && uOk]);

            // Test 6: Consistent pastel hashing
            const c1 = pastelFromLabel('UTC+1');
            const c2 = pastelFromLabel('UTC+1');
            const c3 = pastelFromLabel('UTC+2');
            results.push(['Pastel stable hash', c1 === c2 && c1 !== c3]);

            // Test 7: Sanitizer accepts MultiPolygon
            const mp = {
              type: 'FeatureCollection',
              features: [{ type: 'Feature', properties: { name: 'mp' }, geometry: { type: 'MultiPolygon', coordinates: [
                [[[0,0],[1,0],[1,1],[0,1],[0,0]]],
                [[[-10,-10],[-9,-10],[-9,-9],[-10,-9],[-10,-10]]]
              ] } }]
            };
            const mpClean = sanitizeFeatureCollection(mp);
            results.push(['Sanitizer MultiPolygon ok', isFeatureCollection(mpClean) && mpClean.features.length === 1]);

            setTestResults(results);
          } catch (e) {
            results.push(['Tests threw', e.message || String(e)]);
            setTestResults(results);
          }
        }

        return (
          <div style={{ maxWidth: 1100, margin: '0 auto', padding: 16, fontFamily: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial', color: '#e8ecff' }}>
            <style>{`
              :root { --card: rgba(255,255,255,0.06); --stroke: rgba(255,255,255,0.12); --text: #e8ecff; --muted:#aab4d6; }
              .fancy-bg { position: fixed; inset: -20vmax; z-index: -1; background: radial-gradient(60vmax 60vmax at 20% 10%, #2b5cff22, transparent), radial-gradient(50vmax 50vmax at 80% 30%, #00ffd522, transparent), radial-gradient(40vmax 40vmax at 50% 90%, #ff66cc22, transparent); filter: blur(40px); animation: float 16s ease-in-out infinite alternate; }
              @keyframes float { from { transform: translateY(-8px);} to { transform: translateY(8px);} }
              .card { background: var(--card); border: 1px solid var(--stroke); border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,.35); backdrop-filter: blur(8px); }
              .btn { border: 0; border-radius: 10px; padding: 10px 14px; cursor: pointer; font-weight: 700; transition: transform .12s ease, box-shadow .2s ease; }
              .btn:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,.25); }
              .btn-primary { background: linear-gradient(135deg,#5c7cfa,#4dabf7); color: white; }
              .btn-plain { background: #0b1020; color: var(--text); border: 1px solid var(--stroke); }
              .textarea { width: 100%; height: 140px; background: #081225; color: var(--text); border: 1px solid var(--stroke); border-radius: 12px; padding: 12px; }
              .pill { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border: 1px solid var(--stroke); background: rgba(255,255,255,.05); font-size:12px; }
              .pill button { background: transparent; border: 0; color: #ffffffcc; cursor: pointer; border-radius: 999px; padding: 0 6px; }
              .table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text); }
              .th, .td { padding: 10px 8px; border-bottom: 1px solid rgba(255,255,255,.08); }
              .thead { position: sticky; top: 0; background: #0f1424; z-index: 1; }
            `}</style>
            <div className="fancy-bg" />
            <h1 style={{ margin: 0, fontSize: 28, letterSpacing: .3 }}>
              <span style={{ background: 'linear-gradient(135deg,#91a7ff,#63e6be)', WebkitBackgroundClip: 'text', color: 'transparent', fontWeight: 800 }}>UTC Timezones</span>
              <span style={{ fontSize: 13, color: '#b6c2ff', fontWeight: 600, opacity: .9, marginLeft: 10 }}>real polygons • click to color</span>
            </h1>
            <p style={{ marginTop: 6, color: '#c7d0ff', opacity: .85 }}>Paste addresses, click a zone to log it, click again to undo the last log for that zone.</p>

            <div style={{ display: 'grid', gridTemplateColumns: '1.45fr .55fr', gap: 16, marginTop: 14 }}>
              {/* Map card */}
              <div className="card" style={{ padding: 14 }}>
                <div style={{ marginBottom: 10, color: '#c9d2ff', fontWeight: 700, display:'flex', alignItems:'center', justifyContent:'space-between' }}>
                  <span>Map</span>
                  <span style={{ fontSize: 12, color: '#9fb0ff' }}>{loading ? 'Loading timezones…' : status}</span>
                </div>
                <div ref={mapEl} style={{ height: 560, borderRadius: 12, overflow: 'hidden', boxShadow: 'inset 0 0 0 1px rgba(255,255,255,.06)' }} />
                {selectedZones.length > 0 && (
                  <div style={{ marginTop: 10, display:'flex', flexWrap:'wrap', gap:8 }}>
                    {selectedZones.map((z) => (
                      <span key={z} className="pill">
                        <span style={{ width:10, height:10, borderRadius:999, background: pastelFromLabel(z), boxShadow:'0 0 0 2px rgba(0,0,0,.25) inset' }} />
                        {z}
                        <button title="Remove" onClick={() => {
                          setSelectedZones(prev => prev.filter(p => p !== z));
                          setRows(prev => toggleRowsLifo(prev, z, { addressCount: 0, sample: '', source: 'ne' }).rows);
                        }}>×</button>
                      </span>
                    ))}
                  </div>
                )}
              </div>

              {/* Address card */}
              <div className="card" style={{ padding: 14 }}>
                <div style={{ marginBottom: 10, color: '#c9d2ff', fontWeight: 700 }}>Addresses</div>
                <textarea
                  className="textarea"
                  value={addressInput}
                  onChange={(e) => setAddressInput(e.target.value)}
                  placeholder="Paste crypto addresses (EVM 0x..., Solana base58). One per line or separated by spaces/commas."
                />
                <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 8 }}>
                  <button className="btn btn-primary" onClick={handleParse} disabled={detecting}>Parse</button>
                  <button
                    className="btn btn-primary"
                    onClick={() => handleDetect()}
                    disabled={!addresses.length || detecting}
                  >
                    Run
                  </button>
                  <span style={{ fontSize: 12, color: '#b9c3e6' }}>
                    {detecting
                      ? 'Detecting timezones…'
                      : `${addresses.length} valid address${addresses.length === 1 ? '' : 'es'}`}
                  </span>
                  {detectError && (
                    <span style={{ fontSize: 12, color: '#ff6b6b' }}>{detectError}</span>
                  )}
                  <button className="btn btn-plain" onClick={() => runTests()} style={{ marginLeft: 'auto' }}>
                    Run Tests
                  </button>
                </div>
                {testResults && (
                  <div style={{ marginTop: 8, background: '#0f1a35', border: '1px solid rgba(255,255,255,.12)', borderRadius: 8, padding: 8 }}>
                    <div style={{ fontWeight: 700, marginBottom: 4, color: '#c9d2ff' }}>Tests</div>
                    {testResults.map((r, i) => (
                      <div key={i} style={{ display: 'flex', gap: 8, fontSize: 12, color: '#dbe4ff' }}>
                        <span style={{ opacity: 0.75 }}>{r[0]}:</span>
                        <span>{String(r[1])}</span>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>

            {/* Table under the map */}
            <div className="card" style={{ marginTop: 18, padding: 12 }}>
              <div style={{ fontWeight: 700, marginBottom: 8, color: '#c9d2ff' }}>Clicks</div>
              <div style={{ overflowX: 'auto' }}>
                <table className="table">
                  <thead>
                    <tr className="thead">
                      <th className="th">Timestamp</th>
                      <th className="th">Timezone</th>
                      <th className="th">Source</th>
                      <th className="th">Address Count</th>
                      <th className="th">Addresses</th>
                    </tr>
                  </thead>
                  <tbody>
                    {rows.length === 0 ? (
                      <tr>
                        <td colSpan={5} style={{ padding: 12, opacity: 0.7 }}>No clicks yet. Paste addresses, then click a timezone.</td>
                      </tr>
                    ) : (
                      rows.map((row, idx) => (
                        <tr key={row.ts + idx} style={{ borderBottom: '1px solid rgba(255,255,255,.06)' }}>
                          <td className="td">{row.ts}</td>
                          <td className="td">{row.zone}</td>
                          <td className="td">{row.source}</td>
                          <td className="td">{row.address_count}</td>
                          <td className="td">{row.sample}</td>
                        </tr>
                      ))
                    )}
                  </tbody>
                </table>
              </div>
            </div>

            <div style={{ marginTop: 8, fontSize: 12, color: '#aab4d6' }}>
              Data: Natural Earth time zones (via TopoJSON). Basemap © OSM contributors. No Web3 used.
            </div>
          </div>
        );
      }

      // Mount it
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(TimezoneMapUI));
    </script>
  </body>
</html>
