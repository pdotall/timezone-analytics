<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>UTC Timezones — SIM (Frontend-Only)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="Interactive UTC timezones with real polygons — frontend only using Dune SIM proxy." />
    <style>
      html, body { margin: 0; height: 100%; background: #0b1020; }
      #root { min-height: 100vh; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <!-- React via CDN + Babel so we can use JSX inline for a quick demo -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useEffect, useRef, useState } = React;

      /* =========================================================
         CONFIG — point this to your Cloudflare Worker SIM proxy
         (It should add the SIM API key and CORS: *)
         ========================================================= */
      const SIM_BASE = 'https://smart-money.pdotcapital.workers.dev/v1';

      /* =========================================================
         HELPERS
         ========================================================= */
      const getZoneName = (props = {}) =>
        props.tzid || props.TZID || props.time_zone || props.NAME || props.name || 'Timezone';

      const isEvm = (s) => /^(0x)[0-9a-fA-F]{40}$/.test(s);
      const isSol = (s) => /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(s); // rough base58

      const parseAddresses = (text) => {
        const parts = String(text || '')
          .split(/[\s,;\n\r]+/)
          .map((s) => s.trim())
          .filter(Boolean);
        const seen = new Set();
        const out = [];
        for (const addr of parts) {
          let key = null;
          if (isEvm(addr)) key = addr.toLowerCase();
          else if (isSol(addr)) key = addr;
          else continue;
          if (seen.has(key)) continue;
          seen.add(key);
          out.push(addr);
        }
        return out;
      };

      const pastelFromLabel = (label) => {
        let h = 0;
        const s = String(label || '');
        for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
        const hue = h % 360;
        return `hsl(${hue} 85% 70%)`;
      };

      const isFeatureCollection = (obj) => !!obj && obj.type === 'FeatureCollection' && Array.isArray(obj.features);

      // Geometry validators
      const isNumber = (x) => typeof x === 'number' && Number.isFinite(x);
      const isPosition = (p) => Array.isArray(p) && p.length >= 2 && isNumber(p[0]) && isNumber(p[1]);
      const isLinearRing = (ring) => Array.isArray(ring) && ring.length >= 4 && ring.every(isPosition);
      const isPolygon = (coords) => Array.isArray(coords) && coords.length > 0 && coords.every(isLinearRing);
      const isMultiPolygon = (coords) => Array.isArray(coords) && coords.length > 0 && coords.every(isPolygon);

      function sanitizeFeatureCollection(fcIn) {
        try {
          if (!isFeatureCollection(fcIn)) return null;
          const out = { type: 'FeatureCollection', features: [] };
          for (const feat of fcIn.features || []) {
            if (!feat || typeof feat !== 'object') continue;
            const g = feat.geometry;
            if (!g || typeof g !== 'object') continue;
            if (g.type === 'Polygon' && isPolygon(g.coordinates)) out.features.push(feat);
            else if (g.type === 'MultiPolygon' && isMultiPolygon(g.coordinates)) out.features.push(feat);
          }
          return out.features.length ? out : null;
        } catch {
          return null;
        }
      }

      // Add/Toggle rows (LIFO remove for same zone)
      const toggleRowsLifo = (prevRows, zoneLabel, { addressCount, sample, source }) => {
        const idx = prevRows.findIndex((r) => r.zone === zoneLabel);
        if (idx === 0) return { rows: prevRows.slice(1), toggledOff: true };
        if (idx > 0)  return { rows: [...prevRows.slice(0, idx), ...prevRows.slice(idx + 1)], toggledOff: true };
        const ts = new Date().toISOString();
        return {
          rows: [{ ts, zone: zoneLabel, source: source || 'ne', address_count: addressCount || 0, sample: sample || '' }, ...prevRows],
          toggledOff: false,
        };
      };

      // Fallback FC to keep the map valid if data fails
      const FALLBACK_FC = {
        type: 'FeatureCollection',
        features: [
          {
            type: 'Feature',
            properties: { tzid: 'UTC (fallback)' },
            geometry: { type: 'Polygon', coordinates: [[[-5, 45], [5, 45], [5, 35], [-5, 35], [-5, 45]]] },
          },
        ],
      };

      // Canonicalize any zone label (e.g. "UTC−05:00", "GMT-05", "UTC+5:30") → "UTC-5" or "UTC+5:30"
      function canonicalUtc(label) {
        if (!label) return '';
        let s = String(label).trim();
        s = s.replace(/^GMT/i, 'UTC');        // GMT → UTC
        s = s.replace(/\u2212/g, '-');        // unicode minus → hyphen-minus
        // Accept "UTC+05:00", "UTC-5", "UTC +05", "+5:30", "-03:00", etc.
        const m = s.match(/([Uu][Tt][Cc])?\s*([+-]?)(\d{1,2})(?::?(\d{2}))?/);
        if (!m) return s.startsWith('UTC') ? s : `UTC${s.startsWith('+')||s.startsWith('-') ? '' : '+'}${s}`;
        const sign = m[2] || '+';
        const hh = Math.min(14, Math.max(0, parseInt(m[3], 10)));
        const mm = m[4] ? parseInt(m[4], 10) : 0;
        let hSigned = sign === '-' ? -hh : hh;
        if (mm && mm !== 0) {
          const mmStr = String(Math.min(59, Math.max(0, mm))).padStart(2, '0');
          return `UTC${hSigned >= 0 ? '+' : ''}${hSigned}:${mmStr}`;
        }
        return `UTC${hSigned >= 0 ? '+' : ''}${hSigned}`;
      }

      // IANA-like offset label from integer hour
      const offsetToLabel = (h) => `UTC${h >= 0 ? '+' : ''}${h}`;

      /* =========================================================
         TIMEZONE DETECTION (Frontend-only using SIM)
         ========================================================= */

      // Analyze a 24-length histogram into best UTC offset (same logic as server)
      function analyzeHourlyCounts(counts) {
        const total = counts.reduce((a, b) => a + b, 0);
        const sorted = [...counts].sort((a, b) => a - b);
        const median = sorted[Math.floor(sorted.length / 2)];

        let bestOffset = 0;
        let bestScore = -Infinity;
        for (let offset = -12; offset <= 14; offset++) {
          let daySum = 0;
          for (let i = 0; i < 24; i++) {
            const localHour = (i + offset + 24) % 24;
            if (localHour >= 8 && localHour < 18) daySum += counts[i];
          }
          if (daySum > bestScore) {
            bestScore = daySum;
            bestOffset = offset;
          }
        }
        const utc_label = `UTC${bestOffset >= 0 ? '+' : ''}${bestOffset}`;
        const ratio = total ? bestScore / total : 0;
        const highBars = counts.filter((c) => c >= median * 3).length;

        return {
          utc_offset_hours: bestOffset,
          utc_label,
          median,
          ratio,
          bars_high_over_mult: highBars,
          passes_rule: ratio > 0.5 && highBars >= 3
        };
      }

      // Try to discover all supported chains from SIM. If it fails, use a broad built-in set.
      async function getAllChainIds() {
        try {
          const r = await fetch(`${SIM_BASE}/chains`);
          if (r.ok) {
            const js = await r.json();
            const ids = (js?.chains || js || [])
              .map((c) => Number(c.chain_id ?? c.id))
              .filter((n) => Number.isFinite(n));
            const uniq = Array.from(new Set(ids)).sort((a, b) => a - b);
            if (uniq.length) return uniq;
          }
        } catch {}
        return [
          1, 10, 25, 40, 56, 57, 100, 122, 137, 169, 204, 250, 288, 324, 336, 360, 369, 534, 570, 595, 616, 7700, 8217,
          8453, 9001, 10000, 1030, 1088, 1101, 1284, 1285, 2000, 2222, 4689, 5000, 59140, 59144, 71401, 81457, 42161,
          42170, 42220, 43114, 47805, 50001, 53935
        ];
      }

      // Fetch recent activity for a single address across ALL chains (SIM defaults limits)
      async function fetchAddressHourlyCounts(address, chainIds) {
        const counts = new Array(24).fill(0);
        const CONCURRENCY = 6;
        let idx = 0;

        async function worker() {
          while (idx < chainIds.length) {
            const chainId = chainIds[idx++];
            const url =
              `${SIM_BASE}/evm/activity/${address}`
              + `?chain_ids=${chainId}`
              + `&type=send,receive,mint,burn`
              + `&sort_by=block_time&sort_order=asc`;
            try {
              const r = await fetch(url);
              if (!r.ok) continue;
              const { activity = [] } = await r.json();
              for (const ev of activity) {
                const t = Date.parse(ev.block_time);
                if (!Number.isFinite(t)) continue;
                const h = new Date(t).getUTCHours();
                counts[h] += 1;
              }
            } catch { /* ignore chain errors */ }
          }
        }
        await Promise.all(Array.from({ length: Math.min(CONCURRENCY, chainIds.length) }, () => worker()));
        return counts;
      }

      // Map with concurrency utility
      async function mapWithConcurrency(items, limit, fn) {
        const results = new Array(items.length);
        let i = 0;
        const workers = Array.from({ length: Math.min(limit, items.length) }, async () => {
          while (i < items.length) {
            const idx = i++;
            try {
              results[idx] = await fn(items[idx], idx);
            } catch (e) {
              results[idx] = { error: e?.message || String(e) };
            }
          }
        });
        await Promise.all(workers);
        return results;
      }

      // Main detector (frontend-only)
      async function detectTimezones(addresses = []) {
        const chainIds = await getAllChainIds();
        const perAddress = await mapWithConcurrency(addresses, 4, async (addr) => {
          const counts = await fetchAddressHourlyCounts(addr, chainIds);
          return { address: addr, counts, ...analyzeHourlyCounts(counts) };
        });
        return perAddress;
      }

      /* =========================================================
         UI COMPONENT
         ========================================================= */
      function TimezoneMapUI() {
        const mapEl = useRef(null);
        const mapRef = useRef(null);
        const tzLayerRef = useRef(null);

        const [selectedZones, setSelectedZones] = useState([]); // canonical labels
        const selectedZonesRef = useRef(selectedZones);
        useEffect(() => { selectedZonesRef.current = selectedZones; }, [selectedZones]);

        const [addresses, setAddresses] = useState([]);
        const [addressInput, setAddressInput] = useState('');
        const [rows, setRows] = useState([]);
        const [status, setStatus] = useState('');
        const [loading, setLoading] = useState(false);
        const [detecting, setDetecting] = useState(false);
        const [detectError, setDetectError] = useState('');
        const [zoneAddresses, setZoneAddresses] = useState({}); // key = canonical label
        const zoneAddressesRef = useRef(zoneAddresses);
        useEffect(() => { zoneAddressesRef.current = zoneAddresses; }, [zoneAddresses]);

        // Natural Earth TopoJSON → convert to GeoJSON in-browser
        const TOPO_URL =
          'https://gist.githubusercontent.com/tschaub/cc70281ce4df5358eac38b34409b9ef9/raw/d152ba9e83d7733d9fb5f37f52202c0fcead834a/timezones.json';

        const [geoData, setGeoData] = useState(FALLBACK_FC);

        // External loaders
        const loadScript = (src) => new Promise((resolve, reject) => {
          const existing = document.querySelector(`script[src="${src}"]`);
          if (existing) {
            if (existing.dataset.loaded === 'true') return resolve();
            existing.addEventListener('load', () => resolve());
            existing.addEventListener('error', reject);
            return;
          }
          const s = document.createElement('script'); s.src = src; s.async = true;
          s.onload = () => { s.dataset.loaded = 'true'; resolve(); };
          s.onerror = reject; document.body.appendChild(s);
        });
        const loadCSS = (href) => new Promise((resolve, reject) => {
          const existing = document.querySelector(`link[href="${href}"]`);
          if (existing) return resolve();
          const l = document.createElement('link'); l.rel = 'stylesheet'; l.href = href;
          l.onload = resolve; l.onerror = reject; document.head.appendChild(l);
        });

        // Map init
        useEffect(() => {
          let cancelled = false;
          (async () => {
            try {
              await loadCSS('https://unpkg.com/leaflet@1.9.4/dist/leaflet.css');
              await loadScript('https://unpkg.com/leaflet@1.9.4/dist/leaflet.js');
              if (cancelled) return;
              const L = window.L; if (!L) throw new Error('Leaflet failed to load');

              mapRef.current = L.map(mapEl.current, { minZoom: 1.5, worldCopyJump: true, zoomSnap: 0.25, zoomDelta: 0.25 })
                .setView([20, 0], 2.2);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { opacity: 0.5, attribution: '&copy; OSM' }).addTo(mapRef.current);

              // Load timezones (TopoJSON → GeoJSON)
              setLoading(true);
              try {
                await loadScript('https://unpkg.com/topojson-client@3.1.0/dist/topojson-client.min.js');
                const r = await fetch(TOPO_URL, { cache: 'reload' });
                if (!r.ok) throw new Error(`Failed to fetch TopoJSON (HTTP ${r.status})`);
                const topo = await r.json();
                const objects = topo && topo.objects ? topo.objects : {};
                const keys = Object.keys(objects);
                if (!keys.length) throw new Error('Invalid TopoJSON: no objects');
                const bestKey = keys.find((k) => /time/i.test(k)) || keys[0];
                const fc = window.topojson.feature(topo, objects[bestKey]);
                const sanitized = sanitizeFeatureCollection(fc);
                if (!sanitized) throw new Error('Converted data is not a valid FeatureCollection');
                setGeoData(sanitized);
                setStatus(`Loaded ${sanitized.features?.length ?? 0} zones.`);
              } catch (err) {
                console.error(err);
                setGeoData(FALLBACK_FC);
                setStatus(`Error loading timezones — showing fallback`);
              } finally {
                setLoading(false);
              }

              // Render initial layer
              renderZones();

              // Clear selection if clicking empty map
              mapRef.current.on('click', (e) => {
                if (!e.originalEvent.target.closest?.('.leaflet-interactive')) setSelectedZones([]);
              });
            } catch (err) {
              console.error(err);
              setStatus(err.message || String(err));
            }
          })();

          return () => { cancelled = true; try { mapRef.current?.remove(); } catch {} };
          // eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);

        // Re-style polygons when selection changes
        useEffect(() => {
          if (!tzLayerRef.current) return;
          try {
            tzLayerRef.current.eachLayer((layer) => {
              const feature = layer.feature || {};
              const original = getZoneName(feature.properties || {});
              const canon = canonicalUtc(original);
              const selected = selectedZones.includes(canon);
              const color = pastelFromLabel(canon);

              layer.setStyle({
                fillColor: selected ? color : 'transparent',
                fillOpacity: selected ? 0.6 : 0,
                color: selected ? color : '#6072a6',
                weight: selected ? 2 : 1,
              });

              const count = zoneAddressesRef.current[canon]?.length || 0;
              layer.bindTooltip(`${canon} · ${count}${original && original !== canon ? ` (${original})` : ''}`, {
                sticky: true, direction: 'top'
              });
            });
          } catch {}
        }, [selectedZones]);

        // Re-render polygons when geoData changes
        useEffect(() => { if (mapRef.current) renderZones(); /* eslint-disable-line react-hooks/exhaustive-deps */ }, [geoData]);

        function renderZones() {
          const L = window.L; if (!L || !mapRef.current || !geoData) return;

          if (tzLayerRef.current) {
            try { tzLayerRef.current.remove(); } catch {}
            tzLayerRef.current = null;
          }

          const style = (feature) => {
            const original = getZoneName(feature?.properties || {});
            const canon = canonicalUtc(original);
            const selected = selectedZonesRef.current.includes(canon);
            const color = pastelFromLabel(canon);
            return {
              color: selected ? color : '#6072a6',
              weight: selected ? 2 : 1,
              fillColor: selected ? color : 'transparent',
              fillOpacity: selected ? 0.6 : 0,
            };
          };

          const onEachFeature = (feature, layer) => {
            const original = getZoneName(feature?.properties || {});
            const canon = canonicalUtc(original);
            const count = zoneAddressesRef.current[canon]?.length || 0;
            layer.bindTooltip(`${canon} · ${count}${original && original !== canon ? ` (${original})` : ''}`, {
              sticky: true, direction: 'top'
            });
            layer.on('click', () => {
              setSelectedZones((prev) => {
                const already = prev.includes(canon);
                setRows((prevRows) =>
                  toggleRowsLifo(prevRows, canon, {
                    addressCount: zoneAddressesRef.current[canon]?.length || 0,
                    sample: (zoneAddressesRef.current[canon] || []).join(' | '),
                    source: 'ne',
                  }).rows
                );
                return already ? prev.filter((z) => z !== canon) : [canon, ...prev];
              });
              try { if (layer.getBounds) mapRef.current.fitBounds(layer.getBounds(), { padding: [20, 20] }); } catch {}
            });
          };

          tzLayerRef.current = L.geoJSON(geoData, { style, onEachFeature }).addTo(mapRef.current);
        }

        async function handleDetect(addrList = addresses) {
          if (!addrList.length) return;
          setDetecting(true);
          setDetectError('');
          try {
            const res = await detectTimezones(addrList);
            // Group addresses by detected utc_label (canonicalized)
            const zoneMap = {};
            for (const r of Array.isArray(res) ? res : []) {
              const zRaw = r.utc_label || r.tzid || r.zone || r.utc_zone || offsetToLabel(r.utc_offset_hours || 0);
              const z = canonicalUtc(zRaw);
              if (!z) continue;
              (zoneMap[z] = zoneMap[z] || []).push(r.address);
            }
            const zones = Object.keys(zoneMap);
            if (!zones.length) throw new Error('No timezone returned');
            setZoneAddresses(zoneMap);
            setSelectedZones(zones);
            setRows(() => {
              let rows = [];
              for (const z of zones) {
                rows = toggleRowsLifo(rows, z, {
                  addressCount: zoneMap[z].length,
                  sample: zoneMap[z].join(' | '),
                  source: 'sim',
                }).rows;
              }
              return rows;
            });
            setStatus(`Detected ${addrList.length} address(es) across ${zones.length} zone(s).`);
          } catch (err) {
            console.error(err);
            setDetectError(err.message || 'Timezone detection failed');
          } finally {
            setDetecting(false);
          }
        }

        const handleParse = () => {
          const parsed = parseAddresses(addressInput);
          setAddresses(parsed);
        };

        return (
          <div style={{ maxWidth: 1100, margin: '0 auto', padding: 16, fontFamily: 'Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial', color: '#e8ecff' }}>
            <style>{`
              :root { --card: rgba(255,255,255,0.06); --stroke: rgba(255,255,255,0.12); --text: #e8ecff; --muted:#aab4d6; }
              .fancy-bg { position: fixed; inset: -20vmax; z-index: -1;
                background: radial-gradient(60vmax 60vmax at 20% 10%, #2b5cff22, transparent),
                            radial-gradient(50vmax 50vmax at 80% 30%, #00ffd522, transparent),
                            radial-gradient(40vmax 40vmax at 50% 90%, #ff66cc22, transparent);
                filter: blur(40px); animation: float 16s ease-in-out infinite alternate; }
              @keyframes float { from { transform: translateY(-8px);} to { transform: translateY(8px);} }
              .card { background: var(--card); border: 1px solid var(--stroke); border-radius: 16px;
                box-shadow: 0 20px 60px rgba(0,0,0,.35); backdrop-filter: blur(8px); }
              .btn { border: 0; border-radius: 10px; padding: 10px 14px; cursor: pointer; font-weight: 700;
                transition: transform .12s ease, box-shadow .2s ease; }
              .btn:hover { transform: translateY(-1px); box-shadow: 0 8px 20px rgba(0,0,0,.25); }
              .btn-primary { background: linear-gradient(135deg,#5c7cfa,#4dabf7); color: white; }
              .btn-plain { background: #0b1020; color: var(--text); border: 1px solid var(--stroke); }
              .textarea { width: 100%; height: 140px; background: #081225; color: #e8ecff;
                border: 1px solid var(--stroke); border-radius: 12px; padding: 12px; }
              .pill { display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
                border: 1px solid var(--stroke); background: rgba(255,255,255,.05); font-size:12px; }
              .pill button { background: transparent; border: 0; color: #ffffffcc; cursor: pointer; border-radius: 999px; padding: 0 6px; }
              .table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text); }
              .th, .td { padding: 10px 8px; border-bottom: 1px solid rgba(255,255,255,.08); }
              .thead { position: sticky; top: 0; background: #0f1424; z-index: 1; }
            `}</style>

            <div className="fancy-bg" />
            <h1 style={{ margin: 0, fontSize: 28, letterSpacing: .3 }}>
              <span style={{ background: 'linear-gradient(135deg,#91a7ff,#63e6be)', WebkitBackgroundClip: 'text', color: 'transparent', fontWeight: 800 }}>
                UTC Timezones
              </span>
              <span style={{ fontSize: 13, color: '#b6c2ff', fontWeight: 600, opacity: .9, marginLeft: 10 }}>
                real polygons • SIM (frontend-only)
              </span>
            </h1>
            <p style={{ marginTop: 6, color: '#c7d0ff', opacity: .85 }}>
              Paste addresses, click a zone to log it, click again to undo the last log for that zone.
            </p>

            <div style={{ display: 'grid', gridTemplateColumns: '1.45fr .55fr', gap: 16, marginTop: 14 }}>
              {/* Map card */}
              <div className="card" style={{ padding: 14 }}>
                <div style={{ marginBottom: 10, color: '#c9d2ff', fontWeight: 700, display:'flex', alignItems:'center', justifyContent:'space-between' }}>
                  <span>Map</span>
                  <span style={{ fontSize: 12, color: '#9fb0ff' }}>{loading ? 'Loading timezones…' : status}</span>
                </div>
                <div ref={mapEl} style={{ height: 560, borderRadius: 12, overflow: 'hidden', boxShadow: 'inset 0 0 0 1px rgba(255,255,255,.06)' }} />
                {selectedZones.length > 0 && (
                  <div style={{ marginTop: 10, display:'flex', flexWrap:'wrap', gap:8 }}>
                    {selectedZones.map((z) => (
                      <span key={z} className="pill">
                        <span style={{ width:10, height:10, borderRadius:999, background: pastelFromLabel(z), boxShadow:'0 0 0 2px rgba(0,0,0,.25) inset' }} />
                        {z}
                        <button title="Remove" onClick={() => {
                          setSelectedZones(prev => prev.filter(p => p !== z));
                          setRows(prev => toggleRowsLifo(prev, z, { addressCount: 0, sample: '', source: 'sim' }).rows);
                        }}>×</button>
                      </span>
                    ))}
                  </div>
                )}
              </div>

              {/* Address card */}
              <div className="card" style={{ padding: 14 }}>
                <div style={{ marginBottom: 10, color: '#c9d2ff', fontWeight: 700 }}>Addresses</div>
                <textarea
                  className="textarea"
                  value={addressInput}
                  onChange={(e) => setAddressInput(e.target.value)}
                  placeholder="Paste crypto addresses (EVM 0x..., Solana base58). One per line or separated by spaces/commas."
                />
                <div style={{ display: 'flex', gap: 8, alignItems: 'center', marginTop: 8 }}>
                  <button className="btn btn-primary" onClick={handleParse} disabled={detecting}>Parse</button>
                  <button
                    className="btn btn-primary"
                    onClick={() => handleDetect()}
                    disabled={!addresses.length || detecting}
                  >
                    Run
                  </button>
                  <span style={{ fontSize: 12, color: '#b9c3e6' }}>
                    {detecting
                      ? 'Detecting timezones…'
                      : `${addresses.length} valid address${addresses.length === 1 ? '' : 'es'}`}
                  </span>
                  {detectError && (
                    <span style={{ fontSize: 12, color: '#ff6b6b' }}>{detectError}</span>
                  )}
                  <button
                    className="btn btn-plain"
                    onClick={() => {
                      const results = [];
                      try {
                        const parsed = parseAddresses('0x0000000000000000000000000000000000000000\nfoo\n1BoatSLRHtKNngkdXEeobR76b53LETtpyT\n0x0000000000000000000000000000000000000000');
                        results.push(['Parse EVM + Sol + dedupe', parsed.length >= 2 && parsed[0] !== parsed[1]]);
                        const c1 = pastelFromLabel('UTC+1'), c2 = pastelFromLabel('UTC+1'), c3 = pastelFromLabel('UTC+2');
                        results.push(['Pastel stable hash', c1 === c2 && c1 !== c3]);
                        alert(results.map(([n, ok]) => `${n}: ${ok}`).join('\n'));
                      } catch (e) {
                        alert('Tests threw: ' + (e.message || String(e)));
                      }
                    }}
                    style={{ marginLeft: 'auto' }}
                  >
                    Run Tests
                  </button>
                </div>
              </div>
            </div>

            {/* Table under the map */}
            <div className="card" style={{ marginTop: 18, padding: 12 }}>
              <div style={{ fontWeight: 700, marginBottom: 8, color: '#c9d2ff' }}>Clicks</div>
              <div style={{ overflowX: 'auto' }}>
                <table className="table">
                  <thead>
                    <tr className="thead">
                      <th className="th">Timestamp</th>
                      <th className="th">Timezone</th>
                      <th className="th">Source</th>
                      <th className="th">Address Count</th>
                      <th className="th">Addresses</th>
                    </tr>
                  </thead>
                  <tbody>
                    {rows.length === 0 ? (
                      <tr>
                        <td colSpan={5} style={{ padding: 12, opacity: 0.7 }}>No clicks yet. Paste addresses, then click a timezone.</td>
                      </tr>
                    ) : (
                      rows.map((row, idx) => (
                        <tr key={row.ts + idx} style={{ borderBottom: '1px solid rgba(255,255,255,.06)' }}>
                          <td className="td">{row.ts}</td>
                          <td className="td">{row.zone}</td>
                          <td className="td">{row.source}</td>
                          <td className="td">{row.address_count}</td>
                          <td className="td">{row.sample}</td>
                        </tr>
                      ))
                    )}
                  </tbody>
                </table>
              </div>
            </div>

            <div style={{ marginTop: 8, fontSize: 12, color: '#aab4d6' }}>
              Data: Natural Earth time zones (via TopoJSON). Basemap © OSM contributors. SIM calls via your Cloudflare Worker.
            </div>
          </div>
        );
      }

      // Mount it
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(TimezoneMapUI));
    </script>
  </body>
</html>
